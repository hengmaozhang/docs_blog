### 栈(Stacks)和队列(Queues)

#### 3.1 栈

```c++
template<class T>
class Stack
{ //包含0或多个元素的有限有序表。
public :
	Stack(int stackCapacity=10);
	//创建一个空栈,其初始容量为stackCapacity
	bool IsEmpty()const;
	//如果栈中的元素数量为0,则返回true,否则返回 false
	T& Top()const;
	//返回栈顶元素
	void Push(constT& item);
	//将 item 插入到栈顶
	void Pop();
	//删除栈顶元素
}
```

#### 3.2 队列

```c++
template<class T>
class Queue
{ //包含0或多个元素的有限有序表。
public:
	Queue(int queueCapacity=10) //创建一个空队列,其初始容量为queueCapacity
	bool IsEmpty()const; //如果队列中的元素数量为0,则返回true,否则返回 false
	T& Front()const; //返回队列头元素
	T& Rear()const; //返回队尾元素
	void Push(constT& item); //将 item 插入到队尾
	void Pop();	//删除队列头元素
}
```

队列满了，扩充容量的方法：

 (1) 创建一个两倍容量的新数组 newQueue。
 (2) 把第2段元素(queue[front+1]~queue[capacity-1]之间的元素)复制到newQueue从newQueue[0]开始的位置。
 (3) 把第一段元素(queue[0]~queue[rear]之间的元素)复制到 newQueue 从newQueue_capacity一front-l开始的位置。

```c++
// allocate an array with twice the capacity
T*  newQueue = new T[2*capacity];
// copy from queue to newQueue
int start = (front+1)%capacity;
if (start < 2)
     // no wrap around
     copy(queue+start, queue+start+capacity-1, newQueue);
else
{ // queue wraps around
     copy(queue+start, queue+capacity, newQueue);
     copy(queue, queue+rear+1, newQueue+capacity-start);
}
// switch to newQueue
front = 2*capacity-1;  rear =  capacity-2; capacity *= 2;
delete [] queue;
queue = newQueue;

```

#### 3.3 迷宫问题

**DFS 深度优先搜索**

```c++
void Path(const int m, const int p)
{// Output a path (if any)in the maze, maze[0]{i]= maze [m +1][i]=
	mark[1][1]=1; // stant at (1,1)
	Stack<ltems>stack(m*p);
	ltems temp(l, 1,E); // set temp.x, temp.y, and temp.dir
	stack.Push(temp);
	while(!stack.IsEmptyO)
    { // stack not empty
        temp = stack.Top();
        stack.Pop(); // unstack
        int i = temp.x; int j = temp.y; int d = temp.dir;
        while (d< 8) // move forward
        {
            int g=i+ move[d].a; int h=j+ move[d].b;
            if((g==m)&&(h==p)){ // reached exit
                cout << stack; // output path
                cout << i << " " << j << endl; // last two squares on the path
                cout << m << " ” << p << endl;
                return;
            }
            if ((!maze[g][h])&&(!mark[g][h])){ // new position
                mark[g][h]=1;
                temp.x=i; temp.y=j; temp.dir= d+1;
                stack.Push(temp);// stack it
                i=g;j=h;d=N; // move to (g,h)
            }
            else d++; // try next direction
        }
    }
    cout << "No path in maze." << endl;
}
```

**BFS 广度优先搜索**

```c++
Queue Q;
Q.Push (startPin);
while(!Q.isEmpty())
{
       Pin p = Q.Front();
       Q.Pop();
       for all neighbours pi of p
             Visit(pi)
             Q.Push (pi);
}
```

#### 3.4 前缀，中缀，后缀表达式

<img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20241111220143340.png" alt="image-20241111220143340" style="zoom:33%;" />

### 树

#### 5.1 概述

##### 一.树的表示

1. 广义表表示

   

